# algorithm study
> python algorithm study，阅读书籍：[图解算法]

## 二分查找小结

- 二分查找的速度比简单查找快得多
- O(log n) 比 O(n) 快。需要搜索的元素越多，前者比后者就快的越多
- 算法运行时间并不以秒为单位
- 算法运行时间是从其增速的角度度量的
- 算法运行时间用大 O 表示法表示

## 选择排序小结

- 计算机内存犹如一大堆抽屉
- 需要存储多个元素时，可使用数组或链表
- 数据的元素都在一起
- 链表的元素是分开的， 其中每个元素都存储了下一个元素的地址
- 数组的读取速度很快
- 链表的插入和删除速度很快
- 在同一个数组中，所有元素的类型都必须相同

## 递归栈小结

- 递归指的是调用自己的函数
- 每个递归函数都有两个条件：基线条件和递归条件
- 栈由两种操作：压入和弹出
- 所有函数调用都进入调用栈
- 调用栈可能很长，这将占用大量的内存


## 广度优先搜索小结

- 广度优先搜索指出是否有从A到B的路径
- 如果有，广度优先搜索将找出最短路径
- 面临类似于寻找最短路径的问题时，可尝试是使用图来创建模型，在使用广度优先搜索来解决问题。
- 有向图中的边箭头，箭头的方向指定了关系的方向。
- 无向图中的边不带箭头，其中的关系是双向的。
- 队列是先进先出（FIFO）的。
- 栈是后进先出（LIFO）的。
- 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。
- 对于检查过的人， 务必不要再去检查，否则可能导致无限循环。
- 广度优先搜索的运行时间 O(V+E)。V 是顶点数，E 是边数

## TF-IDF 简介

* TF: Term Freqency(词频)
> 某个词在文章中出现的总词数；词频 = 某个词在文章中出现的总词数 / 文章的总词数 or 某个词在文章中出现的总词数 / 文章中出现次数最多的词的个数；

* IDF: Inverse Document Frequency(逆文档频率)
> 它的大小与一个词的常见程度成反比。逆文档频率 = log(词料库的文档总数 / 包含改词的文档数 + 1)，为了避免分母为 0，所以在分母加 1；

* TF-IDF
> TF-IDF = TF * IDF; TF-IDF 值与改词的出现频率成正比，与在整个语料库中出现次数成反比。

* 提取关键字
> 计算出文章中每个词的 TF-IDF 值后，进行排序，选取其中值最高的几个作为关键字。

* 计算文章的相似度
>  计算出每篇文章的关键词，从中各选取相同个数的关键词，合并成一个集合，计算每篇文章对于这个集合中的词的词频，生成两篇文章各自的词频向量，进而通过欧氏距离或余弦距离求出两个向量的余弦相似度，值越大就表示越相似。

## 狄克斯特拉算法

狄克斯特拉算法包含4个步骤：
1. 找到最便宜的点，即可在最短时间内前往的点。
2. 对于该节点的邻近节点，检查是否有前往它们的更短路径，如果有，就更新其开销。
3. 重复这个过程，直到对图中的每个节点都这样做了。
4. 计算最终路径

### 术语

- 狄克斯特拉算法用于每条边都有关联的数字的图，这些数字称之为权重。
- 带权重的图成为加权图， 不带权重的图成为非加权图。
- 要计算非加权图中的最短路径，可使用广度优先搜索。
- 计算加权图的最短路径，可使用狄克斯特拉算法。狄克斯特拉算法只适用于有向无环图（directed acyclic graph，DAG）。

**狄克斯特拉算法这样假设: 对于处理过的节点，没有前往该节点的更短路径。这种假设仅在没有负权边时才成立。因此狄克斯特拉算法不适用于包含负权边的图**
在包含负权边图中，要找出最短路径，可使用另一种算法--[贝尔曼-福德算法](https://blog.csdn.net/Carinya/article/details/71513904)

### 小结

- 广度优先搜索用于在非加权图中查找最短路径
- 狄克斯特拉算法用于在加权图中查找最短路径
- 仅当权重为正时，狄克斯特拉算法才管用
- 如果图中包含负权边，请使用贝尔曼-福德算法

## 贪婪算法

- 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解
- 对于NP完全问题，还没找到快速解决方案
- 面临NP完全问题时，最佳做法是使用近似算法
- 贪婪算法易于实现、运行速度快，是不错的近似算法

## 动态规划

- 需要在给定约束条件下优化某种指标时，动态规划很有用
- 问题可分解为离散子问题时，可使用动态规划来解决
- 每种动态规划解决方案都涉及网格
- 单元格中的值通常都是要优化的值
- 每个单元格都是一个子问题，因此需要考虑如何将问题分解为子问题
- 没有放之四海皆准的计算动态规划解决方案的公式


